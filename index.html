<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MIL Logic Simulator - Export & Align</title>
    <style>
        body { font-family: sans-serif; display: flex; margin: 0; height: 100vh; overflow: hidden; background: #1a1c2c; user-select: none; }
        
        #sidebar { width: 220px; background: #25283d; color: #efefef; padding: 15px; display: flex; flex-direction: column; gap: 8px; z-index: 10; border-right: 1px solid #444; overflow-y: auto; }
        .component-template { background: #3b3f5c; border: 1px solid #5d6d7e; padding: 10px; cursor: grab; text-align: center; border-radius: 4px; font-weight: bold; font-size: 13px; color: #fff; }
        .component-template:hover { background: #5a608d; }

        .io-section { margin-top: 10px; padding-top: 15px; border-top: 1px solid #444; display: flex; flex-direction: column; gap: 8px; }
        .io-btn { border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; font-size: 12px; }
        .btn-save { background: #3498db; }
        .btn-load { background: #1abc9c; }
        .btn-export { background: #9b59b6; } /* 画像出力用 */
        .btn-align { background: #f39c12; }  /* 整列用 */
        .btn-reset { background: #e74c3c; margin-top: 10px; }
        .io-btn:hover { opacity: 0.8; transform: translateY(-1px); }

        #save-code-area { background: #1a1c2c; border: 1px solid #444; color: #00ffcc; font-family: monospace; font-size: 10px; padding: 8px; width: 100%; box-sizing: border-box; resize: none; height: 60px; border-radius: 4px; }

        #canvas-container { flex-grow: 1; position: relative; background: #1a1c2c; background-image: radial-gradient(#333 1px, transparent 1px); background-size: 25px 25px; }
        
        .gate { 
            position: absolute; width: 80px; height: 50px; background: #2d314d; border: 2px solid #555; 
            display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: move; z-index: 5; border-radius: 4px; text-align: center; color: #fff;
            transition: left 0.3s, top 0.3s; /* 整列時にアニメーションさせる */
        }
        .gate.dragging { transition: none; } /* ドラッグ中はアニメーションをオフ */
        .gate.active-on { border-color: #ff9800; background: #3e3b2b; box-shadow: 0 0 15px rgba(255, 152, 0, 0.3); }
        .gate-label { pointer-events: none; font-size: 11px; white-space: pre; }

        .terminal { position: absolute; width: 14px; height: 14px; background: #555; border-radius: 50%; border: 2px solid #1a1c2c; cursor: pointer; z-index: 10; }
        .terminal:hover { background: #ff5722; transform: scale(1.2); }
        .terminal.selected { background: #ff5722; box-shadow: 0 0 10px #ff5722; border-color: white; }
        
        .in1 { left: -10px; top: 8px; }
        .in2 { left: -10px; top: 28px; }
        .out { right: -10px; top: 18px; }
        .single-in .in1 { top: 18px; }
        
        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .wire { cursor: pointer; pointer-events: stroke; }
        .wire:hover { stroke-width: 8px !important; stroke: #e74c3c !important; }
        .wire-on { stroke: #ff9800; stroke-width: 4; filter: drop-shadow(0 0 5px #ff9800); }
        .wire-off { stroke: #444; stroke-width: 3; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

<div id="sidebar">
    <h3 style="margin:0 0 10px 0">回路パーツ</h3>
    <div class="component-template" draggable="true" data-type="SWITCH">SWITCH</div>
    <div class="component-template" draggable="true" data-type="LIGHT">LIGHT</div>
    <hr style="width:100%; border:0; border-top:1px solid #444">
    <div class="component-template" draggable="true" data-type="AND">AND</div>
    <div class="component-template" draggable="true" data-type="OR">OR</div>
    <div class="component-template" draggable="true" data-type="NOT">NOT</div>
    <div class="component-template" draggable="true" data-type="NAND">NAND</div>
    <div class="component-template" draggable="true" data-type="NOR">NOR</div>
    <div class="component-template" draggable="true" data-type="XOR">XOR</div>
    <div class="component-template" draggable="true" data-type="XNOR">XNOR</div>

    <div class="io-section">
        <textarea id="save-code-area" placeholder="Save/Load code here..."></textarea>
        <button class="io-btn btn-save" onclick="exportCircuit()">SAVE CODE</button>
        <button class="io-btn btn-load" onclick="importCircuit()">LOAD CODE</button>
        <button class="io-btn btn-align" onclick="alignGates()">AUTO ALIGN (整列)</button>
        <button class="io-btn btn-export" onclick="captureCanvas()">CAPTURE IMAGE (画像)</button>
        <button class="io-btn btn-reset" onclick="resetCanvas()">ALL RESET</button>
    </div>
</div>

<div id="canvas-container"><svg id="connections-svg"></svg></div>

<script>
    const container = document.getElementById('canvas-container');
    const svg = document.getElementById('connections-svg');
    let components = [];
    let wires = [];
    let draggingObj = null;
    let selectedTerminal = null;

    // --- 自動整列機能 ---
    function alignGates() {
        const gridSize = 100;
        const padding = 50;
        
        // SWITCH、ゲート、LIGHTの順に並べるなど工夫も可能ですが、
        // 今回は現在の位置に近いグリッドへスナップさせます
        components.forEach(c => {
            c.x = Math.round(c.x / gridSize) * gridSize + 10;
            c.y = Math.round(c.y / gridSize) * gridSize + 25;
            const el = document.getElementById(c.id);
            if(el) {
                el.style.left = c.x + 'px';
                el.style.top = c.y + 'px';
            }
        });
        
        // アニメーションが終わる頃に線を再描画
        let timer = setInterval(drawWires, 16);
        setTimeout(() => clearInterval(timer), 400);
    }

    // --- 画像書き出し機能 ---
    async function captureCanvas() {
        const btn = document.querySelector('.btn-export');
        btn.innerText = "Processing...";
        
        // html2canvasでキャンバス領域を撮影
        const canvas = await html2canvas(container, {
            backgroundColor: '#1a1c2c',
            scale: 2, // 高解像度
            logging: false,
            useCORS: true
        });
        
        const link = document.createElement('a');
        link.download = 'logic-circuit.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        btn.innerText = "CAPTURE IMAGE (画像)";
    }

    function resetCanvas() {
        if (confirm("回路をすべて消去しますか？")) {
            components = []; wires = [];
            container.querySelectorAll('.gate').forEach(el => el.remove());
            document.getElementById('save-code-area').value = "";
            updateLogic();
        }
    }

    function exportCircuit() {
        const data = { components: components.map(c => ({ id: c.id, type: c.type, x: c.x, y: c.y, value: c.value })), wires: wires };
        document.getElementById('save-code-area').value = btoa(JSON.stringify(data));
    }

    function importCircuit() {
        const code = document.getElementById('save-code-area').value.trim();
        if(!code) return;
        try {
            const data = JSON.parse(atob(code));
            components = []; wires = [];
            container.querySelectorAll('.gate').forEach(el => el.remove());
            data.components.forEach(c => createGate(c.type, c.x, c.y, c.id, c.value));
            wires = data.wires;
            updateLogic();
        } catch(e) { alert("ロードに失敗しました。"); }
    }

    function createGate(type, x, y, fixedId = null, initialValue = 0) {
        const id = fixedId || 'c' + Date.now() + Math.random().toString(36).substr(2, 5);
        const comp = { id, type, x, y, value: initialValue, lastClick: 0 };
        components.push(comp);
        
        const el = document.createElement('div');
        el.id = id; 
        el.className = `gate ${['NOT','LIGHT'].includes(type) ? 'single-in' : ''}`;
        el.style.left = x + 'px'; el.style.top = y + 'px';

        const label = document.createElement('span');
        label.className = 'gate-label';
        el.appendChild(label);

        if (type !== 'SWITCH') {
            const names = (type === 'NOT' || type === 'LIGHT') ? ['in1'] : ['in1', 'in2'];
            names.forEach(n => {
                const t = document.createElement('div'); t.className = `terminal ${n}`;
                t.onclick = (ev) => { ev.stopPropagation(); connect(id, n, t); };
                el.appendChild(t);
            });
        }
        if (type !== 'LIGHT') {
            const t = document.createElement('div'); t.className = `terminal out`;
            t.onclick = (ev) => { ev.stopPropagation(); connect(id, 'out', t); };
            el.appendChild(t);
        }

        el.onmousedown = (e) => {
            if(e.target.classList.contains('terminal')) return;
            const now = Date.now();
            if (now - comp.lastClick < 300) {
                components = components.filter(c => c.id !== id);
                wires = wires.filter(w => w.fromId !== id && w.toId !== id);
                el.remove(); updateLogic(); draggingObj = null; return;
            }
            comp.lastClick = now;
            if(type === 'SWITCH') { comp.value = comp.value ? 0 : 1; updateLogic(); }
            draggingObj = comp;
            el.classList.add('dragging');
        };

        container.appendChild(el);
        return id;
    }

    function updateLogic() {
        components.forEach(c => { if(c.type !== 'SWITCH') c.inputs = { in1: 0, in2: 0 }; });
        for(let i = 0; i < 10; i++) {
            wires.forEach(w => {
                const src = components.find(c => c.id === w.fromId);
                const tgt = components.find(c => c.id === w.toId);
                if(src && tgt) tgt.inputs[w.toTerm] = src.value;
            });
            components.forEach(c => {
                const i1 = c.inputs?.in1 || 0; const i2 = c.inputs?.in2 || 0;
                if(c.type === 'AND') c.value = i1 && i2 ? 1 : 0;
                else if(c.type === 'OR') c.value = i1 || i2 ? 1 : 0;
                else if(c.type === 'NOT') c.value = i1 ? 0 : 1;
                else if(c.type === 'NAND') c.value = (i1 && i2) ? 0 : 1;
                else if(c.type === 'NOR') c.value = (i1 || i2) ? 0 : 1;
                else if(c.type === 'XOR') c.value = i1 ^ i2;
                else if(c.type === 'XNOR') c.value = i1 === i2 ? 1 : 0;
                else if(c.type === 'LIGHT') c.value = i1;
                
                const el = document.getElementById(c.id);
                if(el) {
                    const label = el.querySelector('.gate-label');
                    label.innerText = (c.type==='SWITCH'||c.type==='LIGHT') ? `${c.type}\n(${c.value})` : c.type;
                    c.value ? el.classList.add('active-on') : el.classList.remove('active-on');
                }
            });
        }
        drawWires();
    }

    function drawWires() {
        svg.innerHTML = '';
        const cr = container.getBoundingClientRect();
        wires.forEach((w, index) => {
            const fEl = document.getElementById(w.fromId)?.querySelector('.out');
            const tEl = document.getElementById(w.toId)?.querySelector('.' + w.toTerm);
            if(!fEl || !tEl) return;
            const r1 = fEl.getBoundingClientRect(); const r2 = tEl.getBoundingClientRect();
            const sourceComp = components.find(c => c.id === w.fromId);
            const isOn = sourceComp && sourceComp.value === 1;
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", r1.left - cr.left + 7); line.setAttribute("y1", r1.top - cr.top + 7);
            line.setAttribute("x2", r2.left - cr.left + 7); line.setAttribute("y2", r2.top - cr.top + 7);
            line.setAttribute("class", `wire ${isOn ? "wire-on" : "wire-off"}`);
            line.onclick = (e) => { e.stopPropagation(); wires.splice(index, 1); updateLogic(); };
            svg.appendChild(line);
        });
    }

    container.ondragover = e => e.preventDefault();
    container.ondrop = e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('type');
        if(!type) return;
        const rect = container.getBoundingClientRect();
        createGate(type, e.clientX - rect.left - 40, e.clientY - rect.top - 25);
        updateLogic();
    };

    function connect(compId, termName, el) {
        if (!selectedTerminal) {
            selectedTerminal = { id: compId, term: termName, el: el };
            el.classList.add('selected');
        } else {
            const t1 = selectedTerminal;
            if ((t1.term === 'out' && termName !== 'out') || (t1.term !== 'out' && termName === 'out')) {
                const outPart = t1.term === 'out' ? t1 : {id: compId, term: termName};
                const inPart = t1.term !== 'out' ? t1 : {id: compId, term: termName};
                if(outPart.id !== inPart.id) {
                    wires = wires.filter(w => !(w.toId === inPart.id && w.toTerm === inPart.term));
                    wires.push({ fromId: outPart.id, toId: inPart.id, toTerm: inPart.term });
                }
            }
            selectedTerminal.el.classList.remove('selected');
            selectedTerminal = null;
            updateLogic();
        }
    }

    document.querySelectorAll('.component-template').forEach(t => {
        t.ondragstart = e => e.dataTransfer.setData('type', t.dataset.type);
    });

    window.onmousemove = e => {
        if(draggingObj) {
            draggingObj.x += e.movementX; draggingObj.y += e.movementY;
            const el = document.getElementById(draggingObj.id);
            if(el) { el.style.left = draggingObj.x + 'px'; el.style.top = draggingObj.y + 'px'; drawWires(); }
        }
    };
    window.onmouseup = () => { if(draggingObj) document.getElementById(draggingObj.id).classList.remove('dragging'); draggingObj = null; };
</script>
</body>
</html>
