<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MIL Logic Simulator - Comment Support</title>
    <style>
        body { font-family: sans-serif; display: flex; margin: 0; height: 100vh; overflow: hidden; background: #1a1c2c; user-select: none; }
        
        #sidebar { width: 220px; background: #25283d; color: #efefef; padding: 15px; display: flex; flex-direction: column; gap: 8px; z-index: 10; border-right: 1px solid #444; overflow-y: auto; }
        .component-template { background: #3b3f5c; border: 1px solid #5d6d7e; padding: 10px; cursor: grab; text-align: center; border-radius: 4px; font-weight: bold; font-size: 13px; color: #fff; }
        .component-template:hover { background: #5a608d; }
        .template-comment { background: #f1c40f; color: #000; border-color: #d4ac0d; }

        .io-section { margin-top: 10px; padding-top: 15px; border-top: 1px solid #444; display: flex; flex-direction: column; gap: 8px; }
        .io-btn { border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; font-size: 12px; }
        .btn-undo { background: #7f8c8d; }
        .btn-redo { background: #95a5a6; }
        .btn-save { background: #3498db; }
        .btn-load { background: #1abc9c; }
        .btn-export { background: #9b59b6; } 
        .btn-reset { background: #e74c3c; margin-top: 10px; }
        .io-btn:hover { opacity: 0.8; transform: translateY(-1px); }
        .io-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        #save-code-area { background: #1a1c2c; border: 1px solid #444; color: #00ffcc; font-family: monospace; font-size: 10px; padding: 8px; width: 100%; box-sizing: border-box; resize: none; height: 60px; border-radius: 4px; }

        #canvas-container { flex-grow: 1; position: relative; background: #1a1c2c; background-image: radial-gradient(#333 1px, transparent 1px); background-size: 25px 25px; }
        
        .gate { 
            position: absolute; width: 80px; height: 50px; background: #2d314d; border: 2px solid #555; 
            display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: move; z-index: 5; border-radius: 4px; text-align: center; color: #fff;
        }
        .gate.active-on { border-color: #ff9800; background: #3e3b2b; box-shadow: 0 0 15px rgba(255, 152, 0, 0.3); }
        .gate-label { pointer-events: none; font-size: 11px; white-space: pre; }

        /* コメント用スタイル */
        .comment-node {
            position: absolute; min-width: 100px; padding: 8px; background: rgba(241, 196, 15, 0.15); 
            border: 1px dashed #f1c40f; color: #f1c40f; cursor: move; z-index: 4; font-size: 13px; border-radius: 4px;
        }
        .comment-node input {
            background: transparent; border: none; color: inherit; font-family: inherit; font-size: inherit; width: 100%; outline: none;
        }

        .terminal { position: absolute; width: 14px; height: 14px; background: #555; border-radius: 50%; border: 2px solid #1a1c2c; cursor: pointer; z-index: 10; }
        .terminal:hover { background: #ff5722; transform: scale(1.2); }
        .terminal.selected { background: #ff5722; box-shadow: 0 0 10px #ff5722; border-color: white; }
        
        .in1 { left: -10px; top: 8px; }
        .in2 { left: -10px; top: 28px; }
        .out { right: -10px; top: 18px; }
        .single-in .in1 { top: 18px; }
        
        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .wire { cursor: pointer; pointer-events: stroke; fill: none; }
        .wire:hover { stroke-width: 8px !important; stroke: #e74c3c !important; }
        .wire-on { stroke: #ff9800; stroke-width: 4; filter: drop-shadow(0 0 5px #ff9800); }
        .wire-off { stroke: #444; stroke-width: 3; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

<div id="sidebar">
    <h3 style="margin:0 0 10px 0">回路パーツ</h3>
    <div class="component-template" draggable="true" data-type="SWITCH">SWITCH</div>
    <div class="component-template" draggable="true" data-type="LIGHT">LIGHT</div>
    <div class="component-template template-comment" draggable="true" data-type="COMMENT">COMMENT</div>
    <hr style="width:100%; border:0; border-top:1px solid #444">
    <div class="component-template" draggable="true" data-type="AND">AND</div>
    <div class="component-template" draggable="true" data-type="OR">OR</div>
    <div class="component-template" draggable="true" data-type="NOT">NOT</div>
    <div class="component-template" draggable="true" data-type="NAND">NAND</div>
    <div class="component-template" draggable="true" data-type="NOR">NOR</div>
    <div class="component-template" draggable="true" data-type="XOR">XOR</div>
    <div class="component-template" draggable="true" data-type="XNOR">XNOR</div>

    <div class="io-section">
        <div style="display: flex; gap: 4px;">
            <button id="undo-btn" class="io-btn btn-undo" onclick="undo()" style="flex:1">UNDO</button>
            <button id="redo-btn" class="io-btn btn-redo" onclick="redo()" style="flex:1">REDO</button>
        </div>
        <textarea id="save-code-area" placeholder="ここにコードが表示されます..."></textarea>
        <button class="io-btn btn-save" onclick="exportCircuit()">SAVE CODE</button>
        <button class="io-btn btn-load" onclick="importCircuit()">LOAD CODE</button>
        <button class="io-btn btn-export" onclick="captureCanvas()">CAPTURE IMAGE</button>
        <button class="io-btn btn-reset" onclick="resetCanvas()">ALL RESET</button>
    </div>
</div>

<div id="canvas-container"><svg id="connections-svg"></svg></div>

<script>
    const container = document.getElementById('canvas-container');
    const svg = document.getElementById('connections-svg');
    let components = [];
    let wires = [];
    let draggingObj = null;
    let selectedTerminal = null;

    // --- Undo/Redo システム ---
    let history = [];
    let historyIndex = -1;

    function saveHistory() {
        const state = JSON.stringify({
            components: components.map(c => ({...c, lastClick: 0})),
            wires: wires.map(w => ({...w}))
        });
        if (historyIndex >= 0 && history[historyIndex] === state) return;
        history = history.slice(0, historyIndex + 1);
        history.push(state);
        if (history.length > 50) history.shift(); else historyIndex++;
        updateUndoButtons();
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            applyState(JSON.parse(history[historyIndex]));
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            applyState(JSON.parse(history[historyIndex]));
        }
    }

    function applyState(state) {
        components = state.components.map(c => ({...c}));
        wires = state.wires.map(w => ({...w}));
        container.querySelectorAll('.gate, .comment-node').forEach(el => el.remove());
        components.forEach(c => renderComponent(c));
        updateLogic();
        updateUndoButtons();
    }

    function updateUndoButtons() {
        document.getElementById('undo-btn').disabled = historyIndex <= 0;
        document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
    }

    window.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            if (e.key === 'z') { e.preventDefault(); undo(); }
            if (e.key === 'y') { e.preventDefault(); redo(); }
        }
    });

    // --- コンポーネント描画 ---
    function renderComponent(comp) {
        if (comp.type === 'COMMENT') {
            renderComment(comp);
        } else {
            renderGate(comp);
        }
    }

    function renderComment(comp) {
        const el = document.createElement('div');
        el.id = comp.id;
        el.className = 'comment-node';
        el.style.left = comp.x + 'px'; el.style.top = comp.y + 'px';

        const input = document.createElement('input');
        input.value = comp.text || "メモを入力...";
        input.onchange = (e) => { comp.text = e.target.value; saveHistory(); };
        input.onmousedown = (e) => e.stopPropagation(); // ドラッグ防止
        
        el.onmousedown = (e) => {
            const now = Date.now();
            if (now - comp.lastClick < 300) {
                components = components.filter(c => c.id !== comp.id);
                el.remove(); saveHistory(); draggingObj = null; return;
            }
            comp.lastClick = now;
            draggingObj = comp;
        };

        el.appendChild(input);
        container.appendChild(el);
    }

    function renderGate(comp) {
        const el = document.createElement('div');
        el.id = comp.id; 
        el.className = `gate ${['NOT','LIGHT'].includes(comp.type) ? 'single-in' : ''}`;
        el.style.left = comp.x + 'px'; el.style.top = comp.y + 'px';

        const label = document.createElement('span');
        label.className = 'gate-label';
        el.appendChild(label);

        if (comp.type !== 'SWITCH') {
            const names = (comp.type === 'NOT' || comp.type === 'LIGHT') ? ['in1'] : ['in1', 'in2'];
            names.forEach(n => {
                const t = document.createElement('div'); t.className = `terminal ${n}`;
                t.onclick = (ev) => { ev.stopPropagation(); connect(comp.id, n, t); };
                el.appendChild(t);
            });
        }
        if (comp.type !== 'LIGHT') {
            const t = document.createElement('div'); t.className = `terminal out`;
            t.onclick = (ev) => { ev.stopPropagation(); connect(comp.id, 'out', t); };
            el.appendChild(t);
        }

        el.onmousedown = (e) => {
            if(e.target.classList.contains('terminal')) return;
            const now = Date.now();
            if (now - comp.lastClick < 300) {
                components = components.filter(c => c.id !== comp.id);
                wires = wires.filter(w => w.fromId !== comp.id && w.toId !== comp.id);
                el.remove(); saveHistory(); updateLogic(); draggingObj = null; return;
            }
            comp.lastClick = now;
            if(comp.type === 'SWITCH') { comp.value = comp.value ? 0 : 1; saveHistory(); updateLogic(); }
            draggingObj = comp;
        };
        container.appendChild(el);
    }

    function createComponent(type, x, y) {
        const id = 'c' + Date.now() + Math.random().toString(36).substr(2, 5);
        const comp = { id, type, x, y, value: 0, lastClick: 0, text: type === 'COMMENT' ? "メモを入力..." : "" };
        components.push(comp);
        renderComponent(comp);
        saveHistory();
        if (type !== 'COMMENT') updateLogic();
    }

    // --- ロジック・描画更新 ---
    function updateLogic() {
        components.forEach(c => { if(!['SWITCH', 'COMMENT'].includes(c.type)) c.inputs = { in1: 0, in2: 0 }; });
        for(let i = 0; i < 10; i++) {
            wires.forEach(w => {
                const src = components.find(c => c.id === w.fromId);
                const tgt = components.find(c => c.id === w.toId);
                if(src && tgt) tgt.inputs[w.toTerm] = src.value;
            });
            components.forEach(c => {
                if(c.type === 'COMMENT') return;
                const i1 = c.inputs?.in1 || 0; const i2 = c.inputs?.in2 || 0;
                if(c.type === 'AND') c.value = i1 && i2 ? 1 : 0;
                else if(c.type === 'OR') c.value = i1 || i2 ? 1 : 0;
                else if(c.type === 'NOT') c.value = i1 ? 0 : 1;
                else if(c.type === 'NAND') c.value = (i1 && i2) ? 0 : 1;
                else if(c.type === 'NOR') c.value = (i1 || i2) ? 0 : 1;
                else if(c.type === 'XOR') c.value = i1 ^ i2;
                else if(c.type === 'XNOR') c.value = i1 === i2 ? 1 : 0;
                else if(c.type === 'LIGHT') c.value = i1;
                
                const el = document.getElementById(c.id);
                if(el) {
                    const label = el.querySelector('.gate-label');
                    if(label) label.innerText = (c.type==='SWITCH'||c.type==='LIGHT') ? `${c.type}\n(${c.value})` : c.type;
                    c.value ? el.classList.add('active-on') : el.classList.remove('active-on');
                }
            });
        }
        drawWires();
    }

    function drawWires() {
        svg.innerHTML = '';
        const cr = container.getBoundingClientRect();
        wires.forEach((w, index) => {
            const fEl = document.getElementById(w.fromId)?.querySelector('.out');
            const tEl = document.getElementById(w.toId)?.querySelector('.' + w.toTerm);
            if(!fEl || !tEl) return;
            const r1 = fEl.getBoundingClientRect(); const r2 = tEl.getBoundingClientRect();
            const x1 = r1.left - cr.left + 7; const y1 = r1.top - cr.top + 7;
            const x2 = r2.left - cr.left + 7; const y2 = r2.top - cr.top + 7;
            const midX = x1 + (x2 - x1) / 2;
            const points = `${x1},${y1} ${midX},${y1} ${midX},${y2} ${x2},${y2}`;
            const src = components.find(c => c.id === w.fromId);
            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            poly.setAttribute("points", points);
            poly.setAttribute("class", `wire ${src && src.value ? "wire-on" : "wire-off"}`);
            poly.onclick = (e) => { e.stopPropagation(); wires.splice(index, 1); saveHistory(); updateLogic(); };
            svg.appendChild(poly);
        });
    }

    // --- イベント ---
    async function captureCanvas() {
        const btn = document.querySelector('.btn-export');
        btn.innerText = "処理中...";
        const canvas = await html2canvas(container, { backgroundColor: '#1a1c2c', scale: 2, logging: false });
        const link = document.createElement('a');
        link.download = 'logic-circuit.png'; link.href = canvas.toDataURL('image/png'); link.click();
        btn.innerText = "CAPTURE IMAGE";
    }

    function resetCanvas() {
        if (confirm("回路をすべて消去しますか？")) {
            components = []; wires = [];
            container.querySelectorAll('.gate, .comment-node').forEach(el => el.remove());
            saveHistory(); updateLogic();
        }
    }

    function exportCircuit() {
        const data = { components: components.map(c => ({ id: c.id, type: c.type, x: c.x, y: c.y, value: c.value, text: c.text })), wires: wires };
        document.getElementById('save-code-area').value = btoa(JSON.stringify(data));
    }

    function importCircuit() {
        const code = document.getElementById('save-code-area').value.trim();
        if(!code) return;
        try {
            const data = JSON.parse(atob(code));
            applyState(data);
            saveHistory();
        } catch(e) { alert("ロードに失敗しました。"); }
    }

    container.ondragover = e => e.preventDefault();
    container.ondrop = e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('type');
        if(!type) return;
        const rect = container.getBoundingClientRect();
        createComponent(type, e.clientX - rect.left - 40, e.clientY - rect.top - 25);
    };

    function connect(compId, termName, el) {
        if (!selectedTerminal) {
            selectedTerminal = { id: compId, term: termName, el: el };
            el.classList.add('selected');
        } else {
            const t1 = selectedTerminal;
            if ((t1.term === 'out' && termName !== 'out') || (t1.term !== 'out' && termName === 'out')) {
                const outPart = t1.term === 'out' ? t1 : {id: compId, term: termName};
                const inPart = t1.term !== 'out' ? t1 : {id: compId, term: termName};
                if(outPart.id !== inPart.id) {
                    wires = wires.filter(w => !(w.toId === inPart.id && w.toTerm === inPart.term));
                    wires.push({ fromId: outPart.id, toId: inPart.id, toTerm: inPart.term });
                    saveHistory();
                }
            }
            selectedTerminal.el.classList.remove('selected');
            selectedTerminal = null;
            updateLogic();
        }
    }

    document.querySelectorAll('.component-template').forEach(t => {
        t.ondragstart = e => e.dataTransfer.setData('type', t.dataset.type);
    });

    window.onmousemove = e => {
        if(draggingObj) {
            draggingObj.x += e.movementX; draggingObj.y += e.movementY;
            const el = document.getElementById(draggingObj.id);
            if(el) { el.style.left = draggingObj.x + 'px'; el.style.top = draggingObj.y + 'px'; drawWires(); }
        }
    };
    window.onmouseup = () => { if(draggingObj) saveHistory(); draggingObj = null; };

    saveHistory();
</script>
</body>
</html>
